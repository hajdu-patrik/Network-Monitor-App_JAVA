package networkmonitor.db;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.URI;
import java.net.URL;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import networkmonitor.model.BlacklistEntry;

/**
 * Loader class to populate the blacklist database from an external source or manual list.
 * Refactored to comply with SonarQube quality standards.
 */
public class BlacklistLoader {
    // Logger for logging information and errors
    private static final Logger LOGGER = Logger.getLogger(BlacklistLoader.class.getName());
    // SQL insert statement (ID is auto-generated by the database!)
    private static final String INSERT_SQL = "INSERT INTO dbo.netmonitor (ip_address, website_name) VALUES (?, ?)";
    // Constant for valid line check
    private static final String NULL_IP = "0.0.0.0";


    /**
     * Populates the database with blocked IP addresses from a remote URL.
     * Checks against the existing database entries to avoid duplicates.
     * @param sourceUrl The URL of the hosts file.
     * @param limit Maximum number of new entries to process in this batch.
     * @param offset How many lines to skip from the beginning of the file.
     * @param existingEntries List of entries already in the DB (to prevent duplicates).
     * @return The number of entries successfully added to the database.
     */
    public int populateFromUrl(String sourceUrl, int limit, int offset, List<BlacklistEntry> existingEntries) {
        LOGGER.log(Level.INFO, "Loading from URL: {0} (Offset: {1})", new Object[]{sourceUrl, offset});
        int addedCount = 0;
        
        Set<String> existingIps = existingEntries.stream().map(BlacklistEntry::getIpAddress).collect(Collectors.toSet());

        Set<String> currentBatchIps = new HashSet<>();

        Connection conn = null;
        PreparedStatement pstmt = null;

        try {
            URL url = URI.create(sourceUrl).toURL();
            DatabaseManager dbManager = new DatabaseManager();
            conn = dbManager.getConnection();
            conn.setAutoCommit(false); 
            pstmt = conn.prepareStatement(INSERT_SQL);

            try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()))) {
                String line;
                int currentLineIndex = 0;

                while ((line = reader.readLine()) != null) {
                    if (addedCount >= limit)
                        break;

                    if (shouldProcessLine(line, currentLineIndex, offset) &&processAndBatch(line, pstmt, currentBatchIps, existingIps))
                        addedCount++;
                    
                    if (isValidLine(line))
                        currentLineIndex++;
                }
            }

            if (addedCount > 0) {
                LOGGER.info("Saving new unique entries to database...");
                pstmt.executeBatch();
                conn.commit();
                LOGGER.log(Level.INFO, "Batch Complete: Added {0} new entries.", addedCount);
            } else {
                LOGGER.info("No new unique entries found in this batch.");
            }

        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error populating database from URL", e);
            rollbackQuietly(conn);
        } finally {
            closeQuietly(pstmt);
            closeQuietly(conn);
        }
        return addedCount;
    }

    /**
     * Determines if a line should be processed based on validity and offset.
     * @param line The raw line.
     * @param currentLineIndex The index of valid lines encountered so far.
     * @param offset The target offset to start processing from.
     * @return true if the line should be processed, false otherwise.
     */
    private boolean shouldProcessLine(String line, int currentLineIndex, int offset) {
        return isValidLine(line) && currentLineIndex >= offset;
    }

    /**
     * Populates manually, checking for duplicates.
     * @param domains List of domain strings to add.
     */
    public void populateFromList(List<String> domains) {    
        if (domains == null || domains.isEmpty())
            return;
        
        LOGGER.info("Loading from Manual List...");
    }

    private boolean isValidLine(String line) {
        return line != null && line.startsWith(NULL_IP) && !line.equals("0.0.0.0 0.0.0.0");
    }

    /**
     * Processes a line, resolves IP, checks duplicates (both batch and DB), and adds to SQL batch.
     */
    private boolean processAndBatch(String line, PreparedStatement pstmt, Set<String> currentBatchIps, Set<String> existingIps) throws SQLException {
        String[] parts = line.split("\\s+");
        if (parts.length < 2)
            return false;

        String domain = parts[1];
        if (NULL_IP.equals(domain))
            return false;

        try {
            InetAddress address = InetAddress.getByName(domain);
            String realIp = address.getHostAddress();

            // Check against DB and Current Batch
            if (existingIps.contains(realIp) || currentBatchIps.contains(realIp))
                return false;

            pstmt.setString(1, realIp);
            pstmt.setString(2, domain);
            pstmt.addBatch();
            
            currentBatchIps.add(realIp);
            LOGGER.log(Level.INFO, "Resolved & Added: {0} -> {1}", new Object[]{domain, realIp});
            return true;

        } catch (Exception e) {
            return false; 
        }
    }

    /**
     * Rolls back the database transaction without throwing checked exceptions.
     * Used in catch blocks to ensure the transaction is reverted if an error occurs.
     * @param conn The database connection to rollback.
     */
    private void rollbackQuietly(Connection conn) {
        if (conn != null) { 
            try { 
                conn.rollback(); 
            } catch (SQLException ex) {
                // Ignore rollback failure as main exception is already handled.
            } 
        }
    }

    /**
     * Closes an AutoCloseable resource (like Connection, Statement, or ResultSet) safely.
     * Any exceptions thrown during the close operation are caught and ignored.
     * @param resource The resource to close (can be null).
     */
    private void closeQuietly(AutoCloseable resource) {
        if (resource != null) { 
            try { 
                resource.close(); 
            } catch (Exception e) { 
                // Ignore resource closing errors.
            } 
        }
    }
}